//
//  https://mczachurski.dev
//  Copyright Â© 2024 Marcin Czachurski and the repository contributors.
//  Licensed under the Apache License 2.0.
//

import Vapor
import Fluent
import FluentSQL

extension ArchivesController: RouteCollection {
    
    @_documentation(visibility: private)
    static let uri: PathComponent = .constant("archives")
    
    func boot(routes: RoutesBuilder) throws {
        let archivesGroup = routes
            .grouped("api")
            .grouped("v1")
            .grouped(ArchivesController.uri)
            .grouped(UserAuthenticator())
            .grouped(UserPayload.guardMiddleware())

        archivesGroup
            .grouped(EventHandlerMiddleware(.archivesList))
            .grouped(CacheControlMiddleware(.noStore))
            .get(use: list)
        
        archivesGroup
            .grouped(XsrfTokenValidatorMiddleware())
            .grouped(EventHandlerMiddleware(.archivesCreate))
            .grouped(CacheControlMiddleware(.noStore))
            .post(use: create)
    }
}

/// Controller for managing user archives.
///
/// User can request all thair data stored in the system.
/// This controller manages that requests.
///
/// > Important: Base controller URL: `/api/v1/archives`.
struct ArchivesController {
    
    /// List of archives generated by the user.
    ///
    /// An endpoint that returns a list of archive requests.
    ///
    /// > Important: Endpoint URL: `/api/v1/archives`.
    ///
    /// **CURL request:**
    ///
    /// ```bash
    /// curl "https://example.com/api/v1/archives" \
    /// -X GET \
    /// -H "Content-Type: application/json" \
    /// -H "Authorization: Bearer [ACCESS_TOKEN]"
    /// ```
    ///
    /// **Example response body:**
    ///
    /// ```json
    /// [{
    ///     "fileName": "http://storage.com/dsfwrqwe/oZ9qXKgXVTG.zip",
    ///     "createdAt": "2024-02-09T13:23:23.375Z",
    ///     "requestDate": "2024-02-09T13:23:23.375Z",
    ///     "status": "new",
    ///     "id": "7333587676452171777",
    ///     "updatedAt": "2024-02-09T13:23:23.375Z",
    ///     "user": { ... }
    /// }]
    /// ```
    ///
    /// - Parameters:
    ///   - request: The Vapor request to the endpoint.
    ///
    /// - Returns: List of created archive requests.
    ///
    @Sendable
    func list(request: Request) async throws -> [ArchiveDto] {
        guard let authorizationPayloadId = request.userId else {
            throw Abort(.forbidden)
        }
        
        let baseStoragePath = request.application.services.storageService.getBaseStoragePath(on: request.executionContext)
        let baseAddress = request.application.settings.cached?.baseAddress ?? ""
        
        let archivesFromDatabase = try await Archive.query(on: request.db)
            .filter(\.$user.$id == authorizationPayloadId)
            .with(\.$user)
            .sort(\.$requestDate, .descending)
            .all()
        
        return archivesFromDatabase.map({ ArchiveDto(from: $0, baseStoragePath: baseStoragePath, baseAddress: baseAddress) })
    }
    
    /// Create new archive request.
    ///
    /// An endpoint through which a user can create new archive request.
    ///
    /// > Important: Endpoint URL: `/api/v1/archives`.
    ///
    /// **CURL request:**
    ///
    /// ```bash
    /// curl "https://example.com/api/v1/archives" \
    /// -X POST \
    /// -H "Authorization: Bearer [ACCESS_TOKEN]"
    /// ```
    ///
    /// **Example response body:**
    ///
    /// ```json
    /// {
    ///     "fileName": "http://storage.com/dsfwrqwe/oZ9qXKgXVTG.zip",
    ///     "createdAt": "2024-02-09T13:23:23.375Z",
    ///     "requestDate": "2024-02-09T13:23:23.375Z",
    ///     "status": "new",
    ///     "id": "7333587676452171777",
    ///     "updatedAt": "2024-02-09T13:23:23.375Z",
    ///     "user": { ... }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - request: The Vapor request to the endpoint.
    ///
    /// - Returns: Created archive request.
    ///
    /// - Throws: `ArchiveError.requestWaitingForProcessing` if there is already a request waiting for processing..
    /// - Throws: `ArchiveError.processedRequestsAlereadyExist` if processed request already exist.
    /// - Throws: `EntityNotFoundError.archiveNotFound` if archive not exists.
    @Sendable
    func create(request: Request) async throws -> ArchiveDto {
        guard let authorizationPayloadId = request.userId else {
            throw Abort(.forbidden)
        }
        
        let readyArchives = try await Archive.query(on: request.db)
            .filter(\.$user.$id == authorizationPayloadId)
            .filter(\.$status == .ready)
            .count()
        
        guard readyArchives == 0 else {
            throw ArchiveError.processedRequestsAlereadyExist
        }
        
        let processingArchives = try await Archive.query(on: request.db)
            .filter(\.$user.$id == authorizationPayloadId)
            .filter(\.$status ~~ [.new, .processing])
            .count()
        
        guard processingArchives == 0 else {
            throw ArchiveError.requestWaitingForProcessing
        }
        
        let baseStoragePath = request.application.services.storageService.getBaseStoragePath(on: request.executionContext)
        let baseAddress = request.application.settings.cached?.baseAddress ?? ""
        
        let id = request.application.services.snowflakeService.generate()
        let archive = Archive(id: id, userId: authorizationPayloadId)
        try await archive.save(on: request.db)
        
        guard let archiveFromDatabase = try await Archive.query(on: request.db)
            .filter(\.$id == archive.requireID())
            .with(\.$user)
            .first() else {
            throw EntityNotFoundError.archiveNotFound
        }
        
        return ArchiveDto(from: archiveFromDatabase, baseStoragePath: baseStoragePath, baseAddress: baseAddress)
    }
}
